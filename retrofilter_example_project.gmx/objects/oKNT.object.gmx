<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
    björtFX retro crt effect example
    ZIK@MMXX
*/

var _shaderok = shader_is_compiled(shd_retroscreen_screenfilter);
_shaderok &amp;= shader_is_compiled(shd_retroscreen_distortion);
_shaderok &amp;= shader_is_compiled(shd_retroscreen_postprocessing);
_shaderok &amp;= shader_is_compiled(shd_misc_bg);

if (!_shaderok)
{
    show_message("Whoops, seems like the program has failed to compile the shaders...#This program requires a graphics card that supports Shaders!#(You could also, install / update your DirectX drivers and try again to see if it works.)");
    game_end();
}

/// Window settings
winWid = 800;
winHei = 600;
winTargetW = 800;
winTargetH = 600;

/// Shader parameters
// CRT emulation
crtDistortion = 0.25; // screen distortion intensity
crtReflection = 0.3; // border reflection intensity
crtShadowmask = 0.4; // shadow mask intensity
crtScanline   = 0.6; // scanline intensity
crtBleed      = 0.35; // bleed intensity
crtBleedSize  = 64; // bleed size
crtTint       = 0.1; // dynamic colour tint intensity
crtVignette   = 0.1; // vignette intensity
crtFilmgrain  = 0.1; // film grain intensity
crtBrightness = 0.23; // brightness boost/adjustment
crtContrast   = 1.0; // contrast adjustment

// Specular light
// specular light colour
crtSpecularR = 0.9;
crtSpecularG = 0.75;
crtSpecularB = 1.0;
// crtSpecularCol = c_white;
crtSpecularAmp  = 0.1; // specular light amplitude/alpha
crtSpecularOffX = 0.2; // specular light offset x
crtSpecularOffY = -0.2; // specular light offset y

// Final postprocessing FX
crtGlowFactor   = 0.75; // factor/multiplier of glow (hard-capped at certain amount)
crtGlowTint     = 0.75; // colour tint amount of blur (like chromatic aberration)
crtBlurSize     = 8; // half size of blur
crtBlurZoom     = 0.3; // zoom amount of blur

/// Surfaces
surfaceScreenWid = winWid;
surfaceScreenHei = winHei;
surfaceScreen  = surface_create(surfaceScreenWid, surfaceScreenHei); // screen surface that will get the effects applied
surfacePPTemp1 = surface_create(surfaceScreenWid, surfaceScreenHei); // temp. surface to hold the result of pass 1
surfacePPTemp2 = surface_create(surfaceScreenWid, surfaceScreenHei); // temp. surface to hold the result of pass 2
surfacePPTemp3 = surface_create(surfaceScreenWid, surfaceScreenHei); // temp. surface to hold the result of pass 3

/// State of the demo
enum eDEMO_STATE
{
    DEFAULT = 0,
    CUSTOM,
}
demoState = eDEMO_STATE.DEFAULT;
demoBGList = iui_pack(-1, bgTest1, bgTest2, bgTest3, bgTest4, bgTest5, bgTest6);
demoBGCurrent = -1;
demoBGIdx = 0;

demoCustomBGDir = "";
demoCustomBG = -1;

/// Init the UI
iui_init();
UIScale = 1.0;
UIMsg = "";
UIMsgCtr = 0;

draw_set_font(fntConsolas);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update window size
var _winwid = window_get_width();
var _winhei = window_get_height();
if ((_winwid != surfaceScreenWid ||
    _winhei != surfaceScreenHei) &amp;&amp;
    _winwid != 0 &amp;&amp;
    _winhei != 0)
{
    winWid = _winwid;
    winHei = _winhei;
    surfaceScreenWid = _winwid;
    surfaceScreenHei = _winhei;
    
    UIScale = clamp(winWid / winTargetW, 1.0, winHei / winTargetH);
    
    // Resize the application surface
    surface_resize(application_surface, winWid, winHei);
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update surfaces
if (!surface_exists(surfaceScreen) ||
    surface_get_width(surfaceScreen) != surfaceScreenWid ||
    surface_get_height(surfaceScreen) != surfaceScreenHei)
{
    if (surface_exists(surfaceScreen))
        surface_free(surfaceScreen);
    surfaceScreen = surface_create(surfaceScreenWid, surfaceScreenHei);
}

if (!surface_exists(surfacePPTemp1) ||
    surface_get_width(surfacePPTemp1) != surfaceScreenWid ||
    surface_get_height(surfacePPTemp1) != surfaceScreenHei)
{
    if (surface_exists(surfacePPTemp1))
        surface_free(surfacePPTemp1);
    surfacePPTemp1 = surface_create(surfaceScreenWid, surfaceScreenHei);
}

if (!surface_exists(surfacePPTemp2) ||
    surface_get_width(surfacePPTemp2) != surfaceScreenWid ||
    surface_get_height(surfacePPTemp2) != surfaceScreenHei)
{
    if (surface_exists(surfacePPTemp2))
        surface_free(surfacePPTemp2);
    surfacePPTemp2 = surface_create(surfaceScreenWid, surfaceScreenHei);
}

if (!surface_exists(surfacePPTemp3) ||
    surface_get_width(surfacePPTemp3) != surfaceScreenWid ||
    surface_get_height(surfacePPTemp3) != surfaceScreenHei)
{
    if (surface_exists(surfacePPTemp3))
        surface_free(surfacePPTemp3);
    surfacePPTemp3 = surface_create(surfaceScreenWid, surfaceScreenHei);
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update UI
iui_update_io();

// iuiSliderHWid = 8 * UIScale;
// iuiSliderHHei = 16 * UIScale;
if (UIMsgCtr &gt; 0)
    UIMsgCtr--;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset surface target
surface_reset_target();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set surface target
surface_set_target(surfaceScreen);
draw_clear(c_black);

switch (demoState)
{
    case eDEMO_STATE.DEFAULT:
        demoBGCurrent = demoBGList[@ demoBGIdx];
        
        if (!background_exists(demoBGCurrent))
        {
            // Draw background
            var _tex_bayer = sprite_get_texture(texBluenoise, 0);
            
            shader_set(shd_misc_bg);
            
            // Set uniform
            var _u_time = shader_get_uniform(shd_misc_bg, "uTime");
            var _u_resolution = shader_get_uniform(shd_misc_bg, "uScreenResolution");
            var _samp_bayer = shader_get_sampler_index(shd_misc_bg, "uBayer");
            shader_set_uniform_f(_u_time, current_time * 0.001);
            shader_set_uniform_f(_u_resolution, surfaceScreenWid, surfaceScreenHei);
            texture_set_stage(_samp_bayer, _tex_bayer);
            
            // Draw primitive : fullscreen quad for shader based background
            draw_primitive_begin_texture(pr_trianglestrip, -1);
            draw_vertex_texture(0, 0, 0, 0);
            draw_vertex_texture(surfaceScreenWid, 0, 1, 0);
            draw_vertex_texture(0, surfaceScreenHei, 0, 1);
            draw_vertex_texture(surfaceScreenWid, surfaceScreenHei, 1, 1);
            draw_primitive_end();
            shader_reset();
            
            // Draw logo
            var _logot = current_time * 0.001 * pi;
            var _logoscale = 2.0 * UIScale;
            var _logooscampx = surfaceScreenWid * 0.5;
            var _logooscampy = surfaceScreenHei * 0.5;
            var _logox = (surfaceScreenWid + cos(_logot) * _logooscampx) * 0.5;
            var _logoy = (surfaceScreenHei - sin(_logot) * _logooscampy - sprite_get_height(sprLogo) * _logoscale) * 0.5;
            draw_sprite_ext(sprLogo, 0, _logox + 16, _logoy + 16, _logoscale, _logoscale, sin(_logot) * 4, c_black, 0.5);
            draw_sprite_ext(sprLogo, 0, _logox, _logoy, _logoscale, _logoscale, sin(_logot) * 4, c_white, 1.0);
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw screen surface with CRT effects
var _time = current_time * 0.001;

/// Fetch the texture handles
var _texnoise = sprite_get_texture(texBluenoise, 0);
var _texshadowmask = sprite_get_texture(texShadowMask, 0);
var _texrainbowlut = sprite_get_texture(texRainbowLUT, 0);
// (also fetch the texel size of texture)
var _texnoisetexelw = texture_get_texel_width(_texnoise);
var _texnoisetexelh = texture_get_texel_height(_texnoise);
var _texshadowmasktexelw = texture_get_texel_width(_texshadowmask);
var _texshadowmasktexelh = texture_get_texel_height(_texshadowmask);

/// Set texture interpolation
texture_set_interpolation(true);


/// Pass #1 : Screen filter (shadowmask, scanline etc..)
// Feed the results into the temp. surface #1
var _surfw = surface_get_width(surfaceScreen);
var _surfh = surface_get_height(surfaceScreen);
surface_set_target(surfacePPTemp1);

// Set the shader
shader_set(shd_retroscreen_screenfilter);

// Prepare the uniforms
var _u_time                 = shader_get_uniform(shd_retroscreen_screenfilter, "uTime");
var _u_shadowmaskintensity  = shader_get_uniform(shd_retroscreen_screenfilter, "uShadowmaskIntensity");
var _u_scanlineintensity    = shader_get_uniform(shd_retroscreen_screenfilter, "uScanlineIntensity");
var _u_bleendintensity      = shader_get_uniform(shd_retroscreen_screenfilter, "uBleedIntensity");
var _u_bleendsize           = shader_get_uniform(shd_retroscreen_screenfilter, "uBleedSize");
var _u_tintintensity        = shader_get_uniform(shd_retroscreen_screenfilter, "uTintIntensity");
var _u_vignetteintensity    = shader_get_uniform(shd_retroscreen_screenfilter, "uVignetteIntensity");
var _u_grainintensity       = shader_get_uniform(shd_retroscreen_screenfilter, "uFilmgrainIntensity");
var _u_brightness           = shader_get_uniform(shd_retroscreen_screenfilter, "uBrightness");
var _u_contrast             = shader_get_uniform(shd_retroscreen_screenfilter, "uContrast");
var _u_screentexelsize      = shader_get_uniform(shd_retroscreen_screenfilter, "uScreenTexelSize");
var _u_noisetexelsize       = shader_get_uniform(shd_retroscreen_screenfilter, "uNoiseTexelSize");
var _u_shadowmasktexelsize  = shader_get_uniform(shd_retroscreen_screenfilter, "uShadowmaskTexelSize");
var _samp_noise      = shader_get_sampler_index(shd_retroscreen_screenfilter, "uTexNoise");
var _samp_shadowmask = shader_get_sampler_index(shd_retroscreen_screenfilter, "uTexShadowmask");
shader_set_uniform_f(_u_time, _time); // time
shader_set_uniform_f(_u_shadowmaskintensity, crtShadowmask); // intensity of shadow mask effect
shader_set_uniform_f(_u_scanlineintensity, crtScanline); // intensity of scanline
shader_set_uniform_f(_u_bleendintensity, crtBleed); // intensity of colour bleed
shader_set_uniform_f(_u_bleendsize, crtBleedSize); // size of colour bleed
shader_set_uniform_f(_u_tintintensity, crtTint); // intensity of dynamic colour tint
shader_set_uniform_f(_u_vignetteintensity, crtVignette); // intensity of vignette
shader_set_uniform_f(_u_grainintensity, crtFilmgrain); // intensity of film grain
shader_set_uniform_f(_u_brightness, crtBrightness); // brightness boost adjustment
shader_set_uniform_f(_u_contrast, crtContrast); // contrast adjustment
shader_set_uniform_f(_u_screentexelsize, 1 / _surfw, 1 / _surfh); // texel size on surface that's being drawn
shader_set_uniform_f(_u_noisetexelsize, _texnoisetexelw, _texnoisetexelh); // texel size of noise texture
shader_set_uniform_f(_u_shadowmasktexelsize, _texshadowmasktexelw, _texshadowmasktexelh); // texel size of shadow mask texture
texture_set_stage(_samp_noise, _texnoise); // noise texture
texture_set_stage(_samp_shadowmask, _texshadowmask); // shadow mask texture

// Draw surface
draw_surface(surfaceScreen, 0, 0);

// Reset shader
shader_reset();
surface_reset_target();


/// Pass #2 : CRT Screen distortion + Border reflection
// Feed the results into the temp. surface #2
var _surfw = surface_get_width(surfacePPTemp1);
var _surfh = surface_get_height(surfacePPTemp1);
surface_set_target(surfacePPTemp2);

// Set the shader
shader_set(shd_retroscreen_distortion);
// Prepare the uniforms
var _u_time                 = shader_get_uniform(shd_retroscreen_distortion, "uTime");
var _u_distortionintensity  = shader_get_uniform(shd_retroscreen_distortion, "uScreenDistortIntensity");
var _u_reflectionintensity  = shader_get_uniform(shd_retroscreen_distortion, "uBorderReflectionIntensity");
var _u_specularcol          = shader_get_uniform(shd_retroscreen_distortion, "uSpecularLight");
var _u_specularpos          = shader_get_uniform(shd_retroscreen_distortion, "uSpecularLightOffset");
var _u_screentexelsize      = shader_get_uniform(shd_retroscreen_distortion, "uScreenTexelSize");
var _u_noisetexelsize       = shader_get_uniform(shd_retroscreen_distortion, "uNoiseTexelSize");
var _samp_noise             = shader_get_sampler_index(shd_retroscreen_distortion, "uTexNoise");
shader_set_uniform_f(_u_time, _time); // time
shader_set_uniform_f(_u_distortionintensity, crtDistortion); // screen distortion intensity
shader_set_uniform_f(_u_reflectionintensity, crtReflection); // border reflection intensity

// var _specr = (crtSpecularCol &amp; $0000FF), _specg = (crtSpecularCol &amp; $00FF00) &gt;&gt; 8, _specb = (crtSpecularCol &amp; $FF0000) &gt;&gt; 16;
// shader_set_uniform_f(_u_specularcol, _specr / 255, _specg / 255, _specb / 255, crtSpecularAmp);
shader_set_uniform_f(_u_specularcol, crtSpecularR, crtSpecularG, crtSpecularB, crtSpecularAmp); // specular light colour properties (in vec4 format, rgb colour [in 0..1 range] with intensity)
shader_set_uniform_f(_u_specularpos, crtSpecularOffX, crtSpecularOffY); // specular light's offset from center
shader_set_uniform_f(_u_screentexelsize, 1 / _surfw, 1 / _surfh); // texel size on surface that's being drawn
shader_set_uniform_f(_u_noisetexelsize, _texnoisetexelw, _texnoisetexelh); // texel size of noise texture
texture_set_stage(_samp_noise, _texnoise); // noise texture

// Draw surface
draw_surface(surfacePPTemp1, 0, 0);

// Reset shader
shader_reset();
surface_reset_target();


/// Pass #3 : (final postprocessing effects) zoom blur with chromatic abberation
var _surfw = surface_get_width(surfacePPTemp2);
var _surfh = surface_get_height(surfacePPTemp2);
var _winw = window_get_width();
var _winh = window_get_height();

surface_set_target(surfacePPTemp3);
draw_clear(c_black);

// Set the shader
shader_set(shd_retroscreen_postprocessing);
// Prepare the uniforms
var _u_time             = shader_get_uniform(shd_retroscreen_postprocessing, "uTime");
var _u_glowfactor       = shader_get_uniform(shd_retroscreen_postprocessing, "uGlowFactor");
var _u_glowtint         = shader_get_uniform(shd_retroscreen_postprocessing, "uGlowTintIntensity");
var _u_blursize         = shader_get_uniform(shd_retroscreen_postprocessing, "uBlurSize");
var _u_blurzoom         = shader_get_uniform(shd_retroscreen_postprocessing, "uBlurZoomIntensity");
var _u_screentexelsize  = shader_get_uniform(shd_retroscreen_postprocessing, "uScreenTexelSize");
var _u_noisetexelsize   = shader_get_uniform(shd_retroscreen_postprocessing, "uNoiseTexelSize");
var _samp_noise         = shader_get_sampler_index(shd_retroscreen_postprocessing, "uTexNoise");
var _samp_rainbowlut    = shader_get_sampler_index(shd_retroscreen_postprocessing, "uTexRainbow");
shader_set_uniform_f(_u_time, _time); // time
shader_set_uniform_f(_u_glowfactor, crtGlowFactor); // factor/multiplier of glow (hard-capped at certain amount)
shader_set_uniform_f(_u_glowtint, crtGlowTint); // colour tint amount of blur (like chromatic aberration)
shader_set_uniform_f(_u_blursize, crtBlurSize); // half size of blur
shader_set_uniform_f(_u_blurzoom, crtBlurZoom); // zoom amount of blur
shader_set_uniform_f(_u_screentexelsize, 1 / _surfw, 1 / _surfh); // texel size on surface that's being drawn
shader_set_uniform_f(_u_noisetexelsize, _texnoisetexelw, _texnoisetexelh); // texel size of noise texture
texture_set_stage(_samp_noise, _texnoise); // noise texture
texture_set_stage(_samp_rainbowlut, _texrainbowlut); // RGB tint lookup texture

// Draw surface
draw_surface_stretched(surfacePPTemp2, 0, 0, surface_get_width(surfacePPTemp3), surface_get_height(surfacePPTemp3));

// Reset shader
shader_reset();
surface_reset_target();

// Draw the resulting surface
draw_surface_stretched(surfacePPTemp3, 0, 0, _winw, _winh);

/// Reset texture interpolation
texture_set_interpolation(false);

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update &amp; draw immediate mode UI
iui_begin();
/// ====================================================
///     UI vars
/// ====================================================
var _UI_OFF_X = 0, _UI_OFF_Y = 0;
var _UI_CENTER_X = winWid * 0.5, _UI_CENTER_Y = winHei * 0.5;
var _UI_MARGIN = 16 * UIScale;
var _UI_MARGIN2 = _UI_MARGIN * 2;
var _UI_MARGIN_COLUMN = 200 * UIScale;
var _UI_TAB_Y = _UI_OFF_Y + 6 * UIScale;
var _UI_TAB_HEI = 32;
var _UI_MENU_HEI = 128 * UIScale;
var _UI_CONTENT_X = _UI_OFF_X + _UI_MARGIN * 2;
var _UI_CONTENT_Y = _UI_TAB_Y + _UI_TAB_HEI;
var _UI_CURRENT_Y = _UI_CONTENT_Y;
var _UI_ALPHA = 1.0;

/// ====================================================
///     Tabs
/// ====================================================
UI_TAB_IDX = iui_tab(_UI_OFF_X, _UI_TAB_Y, 64, _UI_TAB_HEI, UI_TAB_ELEMENTS, UI_TAB_IDX, 2);

/// ====================================================
///     Tab-specific UI
/// ====================================================
switch (UI_TAB_IDX)
{
    case eTABS.MAIN:
        // var _titlestr = "BJÖRTFX#MMXX ZIK##IDK shdfjhsdfjshda";
        var _titlescale = UIScale * 2;
        var _titleheight = sprite_get_height(sprLogo) * _titlescale; // string_height(_titlestr) * _titlescale;
        var _strscale = UIScale;
        
        _UI_MENU_HEI = 128 * UIScale + _UI_MARGIN * 2; // _titleheight + _UI_MARGIN * 2;
        
        // Backdrop
        iui_rect(_UI_OFF_X, _UI_CURRENT_Y, winWid, _UI_MENU_HEI, UI_BASE_COL);
        _UI_CURRENT_Y += _UI_MARGIN;
    
        // Logo / Info
        // iui_align_push(fa_center, fa_top);
        // iui_label_transform(_UI_CENTER_X, _UI_CURRENT_Y, _titlestr, _titlescale, _titlescale, 0, c_white, 1.0);
        // iui_align_pop();
        var _logoosc = cos(current_time * 0.001 * pi);
        var _logoy = _UI_CURRENT_Y + _logoosc * 8 * UIScale;
        draw_sprite_ext(sprLogo, 0, _UI_CENTER_X, _logoy, _titlescale, _titlescale, 0, c_white, 1.0);
        
        // Preset pictures
        var _picname = "PRESET IMG. : " + string(demoBGIdx + 1);
        iui_align_push(fa_left, fa_top);
        iui_label_transform(_UI_CONTENT_X, _UI_CURRENT_Y, _picname, _strscale, _strscale, 0, UI_ACCENT_COL, 1.0);
        iui_align_pop();
        _UI_CURRENT_Y += _UI_MARGIN2;
        
        // Button
        var _buttonw = 32 * UIScale;
        var _buttonw2 = _buttonw * 2 + _UI_MARGIN;
        var _buttonh = 32 * UIScale;
        var _prev = iui_button(_UI_CONTENT_X, _UI_CURRENT_Y, _buttonw, _buttonh, "&lt;##PREV_BG");
        var _next = iui_button(_UI_CONTENT_X + _buttonw + _UI_MARGIN, _UI_CURRENT_Y, _buttonw, _buttonh, "&gt;##NEXT_BG");
        var _load = iui_button(_UI_CONTENT_X, _UI_CURRENT_Y + _buttonh + _UI_MARGIN, _buttonw2, _buttonh, "LOAD...##SET_BG");
        var _save = iui_button(winWid - _buttonw2 * 2 - _UI_MARGIN, _UI_CURRENT_Y, _buttonw2 * 2, _buttonh, "EXPORT IMG...##SET_BG");
        
        if (_prev || _next)
        {
            var _bgoffset = _next - _prev;
            var _bglistsz = array_length_1d(demoBGList);
            demoBGIdx = (demoBGIdx + _bgoffset + _bglistsz) % _bglistsz;
            demoState = eDEMO_STATE.DEFAULT;
        }
        
        if (_load)
        {
            // var _dir = get_open_filename_ext("image files|*.png;*.gif|*.jpg|*.jpeg", "", working_directory, "Select an image to load...");
            var _dir = get_open_filename_ext(".PNG image file|*.png", "", working_directory, "Select an image to load...");
            if (_dir != "" &amp;&amp; file_exists(_dir))
            {
                demoCustomBGDir = _dir;
                
                if (background_exists(demoCustomBG))
                    background_delete(demoCustomBG);
                demoCustomBG = background_add(_dir, false, false);
                
                if (background_exists(demoCustomBG))
                {
                    UIMsg = "SUCCESSFULLY LOADED THE IMAGE!";
                    UIMsgCtr = room_speed * 3.0;
                    demoState = eDEMO_STATE.CUSTOM;
                }
                else
                {
                    UIMsg = "UNABLE TO LOAD THE IMAGE!#(only .png formats are supported as of now)";
                    UIMsgCtr = room_speed * 3.0;
                    demoState = eDEMO_STATE.DEFAULT;
                }
            }
        }
        else if (_save)
        {
            var _dir = get_save_filename_ext(".PNG image file|*.png", "", working_directory, "Save image to where?");
            if (_dir != "")
            {
                surface_save(surfacePPTemp3, _dir);
                UIMsg = "IMAGE EXPORTED!";
                UIMsgCtr = room_speed * 3.0;
            }
        }
        _UI_CURRENT_Y += _UI_MARGIN2;
        
        _UI_CURRENT_Y += _titleheight;
        break;
        
    case eTABS.CONFIG_SCREEN:
        var _itemx1 = _UI_CONTENT_X;
        var _itemx2 = _itemx1 + _UI_MARGIN_COLUMN;
        var _itemx3 = _itemx2 + _UI_MARGIN_COLUMN;
        
        var _sliderx1 = _itemx1 + 64 * UIScale;
        var _sliderx2 = _itemx2 + 64 * UIScale;
        var _sliderx3 = _itemx3 + 64 * UIScale;
        
        var _sliderw = 128 * UIScale;
        var _sliderhalfh = iuiSliderHHei * 0.5;
        var _titlescale = UIScale;
        var _strscale = UIScale * 0.5;
    
        // Update UI alpha
        if (!point_in_rectangle(iui_inputX, iui_inputY, _UI_OFF_X, _UI_CURRENT_Y, _UI_OFF_X + _sliderx3 + _UI_MARGIN_COLUMN, _UI_CURRENT_Y + _UI_MENU_HEI))
            _UI_ALPHA = 0.25;
    
        // Backdrop
        iui_rect_alpha(_UI_OFF_X, _UI_CURRENT_Y, _sliderx3 + _UI_MARGIN_COLUMN, _UI_MENU_HEI, UI_BASE_COL, _UI_ALPHA);
        // _UI_CURRENT_Y += _UI_MARGIN;
        
        /// 1st column
        /// CRT emulation params
        iui_align_push(fa_left, fa_top);
        iui_label_transform(_itemx1, _UI_CURRENT_Y, "CRT SCREEN", _titlescale, _titlescale, 0, c_white, _UI_ALPHA);
        _UI_CURRENT_Y += _UI_MARGIN2;
        iui_align_pop();
        
        // distortion intensity
        iui_align_push(fa_right, fa_middle);
        iui_label_transform(_sliderx1, _UI_CURRENT_Y + _sliderhalfh, "DISTORTION ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtDistortion = iui_slider_h(_sliderx1, _UI_CURRENT_Y, crtDistortion, _sliderw, -1, 2, "DISTORTION");
        _UI_CURRENT_Y += _UI_MARGIN;
        
        // reflection intensity
        iui_label_transform(_sliderx1, _UI_CURRENT_Y + _sliderhalfh, "REFLECTION ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtReflection = iui_slider_h(_sliderx1, _UI_CURRENT_Y, crtReflection, _sliderw, 0, 1, "REFLECTION");
        _UI_CURRENT_Y += _UI_MARGIN;
        
        // shadow mask intensity
        iui_label_transform(_sliderx1, _UI_CURRENT_Y + _sliderhalfh, "SHADOWMASK ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtShadowmask = iui_slider_h(_sliderx1, _UI_CURRENT_Y, crtShadowmask, _sliderw, 0, 1, "SHADOWMASK");
        _UI_CURRENT_Y += _UI_MARGIN;
        // iui_align_pop();
        
        /// 2nd column
        _UI_CURRENT_Y = _UI_CONTENT_Y + _UI_MARGIN2;
        
        // scanline
        // iui_align_push(fa_right, fa_middle);
        iui_label_transform(_sliderx2, _UI_CURRENT_Y + _sliderhalfh, "SCANLINE ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtScanline = iui_slider_h(_sliderx2, _UI_CURRENT_Y, crtScanline, _sliderw, 0, 1, "SCANLINE");
        _UI_CURRENT_Y += _UI_MARGIN;
        
        // colour bleed
        iui_label_transform(_sliderx2, _UI_CURRENT_Y + _sliderhalfh, "BLEED AMP. ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtBleed = iui_slider_h(_sliderx2, _UI_CURRENT_Y, crtBleed, _sliderw, 0, 1, "BLEED_AMP");
        _UI_CURRENT_Y += _UI_MARGIN;
        
        // colour bleed size
        iui_label_transform(_sliderx2, _UI_CURRENT_Y + _sliderhalfh, "BLEED SZ. ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtBleedSize = iui_slider_h(_sliderx2, _UI_CURRENT_Y, crtBleedSize, _sliderw, -128, 128, "BLEED_SZ");
        _UI_CURRENT_Y += _UI_MARGIN;
        // iui_align_pop();
        
        // dynamic colour tint
        iui_label_transform(_sliderx2, _UI_CURRENT_Y + _sliderhalfh, "COL. TINT ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtTint = iui_slider_h(_sliderx2, _UI_CURRENT_Y, crtTint, _sliderw, 0, 1, "TINT_AMP");
        _UI_CURRENT_Y += _UI_MARGIN;
        
        /// 3nd column
        _UI_CURRENT_Y = _UI_CONTENT_Y + _UI_MARGIN2;
        
        // vignette
        iui_label_transform(_sliderx3, _UI_CURRENT_Y + _sliderhalfh, "VIGNETTE ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtVignette = iui_slider_h(_sliderx3, _UI_CURRENT_Y, crtVignette, _sliderw, 0, 1, "VIGNETTE");
        _UI_CURRENT_Y += _UI_MARGIN;
        
        // film grain
        iui_label_transform(_sliderx3, _UI_CURRENT_Y + _sliderhalfh, "Film grain ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtFilmgrain = iui_slider_h(_sliderx3, _UI_CURRENT_Y, crtFilmgrain, _sliderw, 0, 1, "FILMGRAIN");
        _UI_CURRENT_Y += _UI_MARGIN;
        iui_align_pop();
        break;
        
    case eTABS.CONFIG_SCREEN2:
        var _itemx1 = _UI_CONTENT_X;
        var _itemx2 = _itemx1 + _UI_MARGIN_COLUMN;
        var _itemx3 = _itemx2 + _UI_MARGIN_COLUMN;
        
        var _sliderx1 = _itemx1 + 64 * UIScale;
        var _sliderx2 = _itemx2 + 64 * UIScale;
        var _sliderx3 = _itemx3 + 64 * UIScale;
        
        var _sliderw = 128 * UIScale;
        var _sliderhalfh = iuiSliderHHei * 0.5;
        var _titlescale = UIScale;
        var _strscale = UIScale * 0.5;
        
        // Update UI alpha
        if (!point_in_rectangle(iui_inputX, iui_inputY, _UI_OFF_X, _UI_CURRENT_Y, _UI_OFF_X + _sliderx3 + _UI_MARGIN_COLUMN, _UI_CURRENT_Y + _UI_MENU_HEI))
            _UI_ALPHA = 0.25;
        
        // Backdrop
        iui_rect_alpha(_UI_OFF_X, _UI_CURRENT_Y, _sliderx3 + _UI_MARGIN_COLUMN, _UI_MENU_HEI, UI_BASE_COL, _UI_ALPHA);
        // _UI_CURRENT_Y += _UI_MARGIN;
        
        /// CRT emulation params
        iui_align_push(fa_left, fa_top);
        iui_label_transform(_itemx1, _UI_CURRENT_Y, "COLOUR", _titlescale, _titlescale, 0, c_white, _UI_ALPHA);
        _UI_CURRENT_Y += _UI_MARGIN2;
        iui_align_pop();
        
        // brightness
        iui_align_push(fa_right, fa_middle);
        iui_label_transform(_sliderx1, _UI_CURRENT_Y + _sliderhalfh, "BRIGHTNESS ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtBrightness = iui_slider_h(_sliderx1, _UI_CURRENT_Y, crtBrightness, _sliderw, -1, 2, "BRIGHTNESS");
        _UI_CURRENT_Y += _UI_MARGIN;
        
        // contrast
        iui_label_transform(_sliderx1, _UI_CURRENT_Y + _sliderhalfh, "CONTRAST ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtContrast = iui_slider_h(_sliderx1, _UI_CURRENT_Y, crtContrast, _sliderw, 0, 2, "CONTRAST");
        _UI_CURRENT_Y += _UI_MARGIN;
        iui_align_pop();
        
        /// Specular light
        _UI_CURRENT_Y = _UI_CONTENT_Y;
        iui_align_push(fa_left, fa_top);
        iui_label_transform(_itemx2, _UI_CURRENT_Y, "SCREEN SPECULAR", _titlescale, _titlescale, 0, c_white, _UI_ALPHA);
        _UI_CURRENT_Y += _UI_MARGIN2;
        iui_align_pop();
        
        // red
        iui_align_push(fa_right, fa_middle);
        iui_label_transform(_sliderx2, _UI_CURRENT_Y + _sliderhalfh, "R ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtSpecularR = iui_slider_h(_sliderx2, _UI_CURRENT_Y, crtSpecularR, _sliderw, 0, 1, "RED");
        _UI_CURRENT_Y += _UI_MARGIN;
        
        // green
        iui_label_transform(_sliderx2, _UI_CURRENT_Y + _sliderhalfh, "G ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtSpecularG = iui_slider_h(_sliderx2, _UI_CURRENT_Y, crtSpecularG, _sliderw, 0, 1, "GRN");
        _UI_CURRENT_Y += _UI_MARGIN;
        
        // blue
        iui_label_transform(_sliderx2, _UI_CURRENT_Y + _sliderhalfh, "B ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtSpecularB = iui_slider_h(_sliderx2, _UI_CURRENT_Y, crtSpecularB, _sliderw, 0, 1, "BLU");
        _UI_CURRENT_Y += _UI_MARGIN;
        
        // amplitude
        iui_label_transform(_sliderx2, _UI_CURRENT_Y + _sliderhalfh, "AMP. ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtSpecularAmp = iui_slider_h(_sliderx2, _UI_CURRENT_Y, crtSpecularAmp, _sliderw, 0, 1, "SPECULAR_AMP");
        _UI_CURRENT_Y += _UI_MARGIN;
        // iui_align_pop();
        
        /// Specular light : position
        _UI_CURRENT_Y = _UI_CONTENT_Y + _UI_MARGIN2;
        
        // red
        // iui_align_push(fa_right, fa_middle);
        iui_label_transform(_sliderx3, _UI_CURRENT_Y + _sliderhalfh, "X OFF. ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtSpecularOffX = iui_slider_h(_sliderx3, _UI_CURRENT_Y, crtSpecularOffX, _sliderw, -1, 1, "SPECULAR_X");
        _UI_CURRENT_Y += _UI_MARGIN;
        
        // green
        iui_label_transform(_sliderx3, _UI_CURRENT_Y + _sliderhalfh, "Y OFF. ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtSpecularOffY = iui_slider_h(_sliderx3, _UI_CURRENT_Y, crtSpecularOffY, _sliderw, -1, 1, "SPECULAR_Y");
        _UI_CURRENT_Y += _UI_MARGIN;
        iui_align_pop();
        break;
        
    case eTABS.CONFIG_POSTFX:
        var _itemx1 = _UI_CONTENT_X;
        var _itemx2 = _itemx1 + _UI_MARGIN_COLUMN;
        var _itemx3 = _itemx2 + _UI_MARGIN_COLUMN;
        
        var _sliderx1 = _itemx1 + 64 * UIScale;
        var _sliderx2 = _itemx2 + 64 * UIScale;
        var _sliderx3 = _itemx3 + 64 * UIScale;
        
        var _sliderw = 128 * UIScale;
        var _sliderhalfh = iuiSliderHHei * 0.5;
        var _titlescale = UIScale;
        var _strscale = UIScale * 0.5;
        
        // Update UI alpha
        if (!point_in_rectangle(iui_inputX, iui_inputY, _UI_OFF_X, _UI_CURRENT_Y, _UI_OFF_X + _itemx2, _UI_CURRENT_Y + _UI_MENU_HEI))
            _UI_ALPHA = 0.25;
        
        // Backdrop
        iui_rect_alpha(_UI_OFF_X, _UI_CURRENT_Y, _itemx2, _UI_MENU_HEI, UI_BASE_COL, _UI_ALPHA);
        
        /// Final FX configs
        iui_align_push(fa_left, fa_top);
        iui_label_transform(_itemx1, _UI_CURRENT_Y, "FINAL FX.", _titlescale, _titlescale, 0, c_white, _UI_ALPHA);
        _UI_CURRENT_Y += _UI_MARGIN2;
        iui_align_pop();
        
        // glow factor
        iui_align_push(fa_right, fa_middle);
        iui_label_transform(_sliderx1, _UI_CURRENT_Y + _sliderhalfh, "GLOW FACTOR ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtGlowFactor = iui_slider_h(_sliderx1, _UI_CURRENT_Y, crtGlowFactor, _sliderw, 0, 1, "GLOW_AMP");
        _UI_CURRENT_Y += _UI_MARGIN;
        
        // glow's colour tint amount
        iui_label_transform(_sliderx1, _UI_CURRENT_Y + _sliderhalfh, "GLOW TINT ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtGlowTint = iui_slider_h(_sliderx1, _UI_CURRENT_Y, crtGlowTint, _sliderw, 0, 1, "GLOW_TINT");
        _UI_CURRENT_Y += _UI_MARGIN;
        
        // blur size
        iui_label_transform(_sliderx1, _UI_CURRENT_Y + _sliderhalfh, "BLUR SIZE ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtBlurSize = iui_slider_h(_sliderx1, _UI_CURRENT_Y, crtBlurSize, _sliderw, 0, 32, "BLUR_SZ");
        _UI_CURRENT_Y += _UI_MARGIN;
        
        // blur zoom amount
        iui_label_transform(_sliderx1, _UI_CURRENT_Y + _sliderhalfh, "BLUR ZOOM ", _strscale, _strscale, 0, UI_ACCENT_COL, _UI_ALPHA);
        _UI_CURRENT_Y += 8 * UIScale;
        crtBlurZoom = iui_slider_h(_sliderx1, _UI_CURRENT_Y, crtBlurZoom, _sliderw, 0, 1, "BLUR_ZOOM");
        _UI_CURRENT_Y += _UI_MARGIN;
        iui_align_pop();
        break;
}

/// UI Message
if (UIMsgCtr &gt; 0)
{
    var _msgscale = 3 * UIScale;
    iui_align_center();
    iui_label_shadow(_UI_CENTER_X, winHei * 0.8, UIMsg, iuPiss, _msgscale, _msgscale, c_black);
    iui_align_pop();
}

iui_end();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw contents into the surface
switch (demoState)
{
    case eDEMO_STATE.DEFAULT:
        demoBGCurrent = demoBGList[@ demoBGIdx];
        
        if (background_exists(demoBGCurrent))
        {
            var _bgwid = background_get_width(demoBGCurrent);
            var _bghei = background_get_height(demoBGCurrent);
            var _bgscale = min(surfaceScreenWid / _bgwid, surfaceScreenHei / _bghei);
            _bgwid *= _bgscale;
            _bghei *= _bgscale;
            var _bgx = (surfaceScreenWid - _bgwid) * 0.5;
            var _bgy = (surfaceScreenHei - _bghei) * 0.5;
            draw_background_ext(demoBGCurrent, _bgx, _bgy, _bgscale, _bgscale, 0, c_white, 1.0);
        }
        break;
        
    case eDEMO_STATE.CUSTOM:
        var _bg = demoCustomBG;
        var _bgwid = background_get_width(_bg);
        var _bghei = background_get_height(_bg);
        var _bgscale = min(surfaceScreenWid / _bgwid, surfaceScreenHei / _bghei);
        _bgwid *= _bgscale;
        _bghei *= _bgscale;
        var _bgx = (surfaceScreenWid - _bgwid) * 0.5;
        var _bgy = (surfaceScreenHei - _bghei) * 0.5;
        draw_background_ext(_bg, _bgx, _bgy, _bgscale, _bgscale, 0, c_white, 1.0);
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
