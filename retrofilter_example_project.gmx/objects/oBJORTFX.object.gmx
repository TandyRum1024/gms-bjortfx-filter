<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// BJÃ–RTFX : Fitler handler
/// Shader supported flag
filterSupported = shader_is_compiled(shd_retroscreen_screenfilter);
filterSupported &amp;= shader_is_compiled(shd_retroscreen_distortion);
filterSupported &amp;= shader_is_compiled(shd_retroscreen_postprocessing);

/// Shader parameters
// CRT emulation
crtDistortion = 0.25; // screen distortion intensity
crtReflection = 0.3; // border reflection intensity
crtShadowmask = 0.4; // shadow mask intensity
crtScanline   = 0.6; // scanline intensity
crtBleed      = 0.35; // bleed intensity
crtBleedSize  = 64; // bleed size
crtTint       = 0.1; // dynamic colour tint intensity
crtVignette   = 0.1; // vignette intensity
crtFilmgrain  = 0.1; // film grain intensity
crtBrightness = 0.23; // brightness boost/adjustment
crtContrast   = 1.0; // contrast adjustment

// Specular light
// (specular light colour : RGB values in 0..1 range)
crtSpecularR = 0.9;
crtSpecularG = 0.75;
crtSpecularB = 1.0;
crtSpecularAmp  = 0.1; // specular light amplitude/alpha
crtSpecularOffX = 0.2; // specular light offset x
crtSpecularOffY = -0.2; // specular light offset y

// Final postprocessing FX
crtGlowFactor   = 0.75; // factor/multiplier of glow (hard-capped at certain amount)
crtGlowTint     = 0.75; // colour tint amount of blur (like chromatic aberration)
crtBlurSize     = 8; // half size of blur
crtBlurZoom     = 0.3; // zoom amount of blur

/// Surfaces
// screen resolution
surfaceScreenWid = window_get_width();
surfaceScreenHei = window_get_height();
// downscaled screen resolution
surfaceDownscaleFactor = 1;
surfaceDownscaledWid = surfaceScreenWid &gt;&gt; surfaceDownscaleFactor;
surfaceDownscaledHei = surfaceScreenHei &gt;&gt; surfaceDownscaleFactor;
surfacePPDownscaled = surface_create(surfaceDownscaledWid, surfaceDownscaledHei); // surface holding the downscaled screen
surfacePPTemp1 = surface_create(surfaceScreenHei, surfaceScreenHei); // temp. surface to hold the result of pass 1
surfacePPTemp2 = surface_create(surfaceScreenWid, surfaceScreenHei); // temp. surface to hold the result of pass 2
application_surface_draw_enable(false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update surfaces
if (!surface_exists(surfacePPDownscaled) ||
    surface_get_width(surfacePPDownscaled) != surfaceDownscaledWid ||
    surface_get_height(surfacePPDownscaled) != surfaceDownscaledHei)
{
    if (surface_exists(surfacePPDownscaled))
        surface_free(surfacePPDownscaled);
    surfacePPDownscaled = surface_create(surfaceDownscaledWid, surfaceDownscaledHei);
}

if (!surface_exists(surfacePPTemp1) ||
    surface_get_width(surfacePPTemp1) != surfaceScreenWid ||
    surface_get_height(surfacePPTemp1) != surfaceScreenWid)
{
    if (surface_exists(surfacePPTemp1))
        surface_free(surfacePPTemp1);
    surfacePPTemp1 = surface_create(surfaceScreenWid, surfaceScreenWid);
}

if (!surface_exists(surfacePPTemp2) ||
    surface_get_width(surfacePPTemp2) != surfaceScreenWid ||
    surface_get_height(surfacePPTemp2) != surfaceScreenHei)
{
    if (surface_exists(surfacePPTemp2))
        surface_free(surfacePPTemp2);
    surfacePPTemp2 = surface_create(surfaceScreenWid, surfaceScreenHei);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw screen surface with CRT effects
var _time = current_time * 0.001;

/// Fetch the texture handles
var _texnoise = sprite_get_texture(texBluenoise, 0);
var _texshadowmask = sprite_get_texture(texShadowMask, 0);
var _texrainbowlut = sprite_get_texture(texRainbowLUT, 0);
// (also fetch the texel size of texture)
var _texnoisetexelw = texture_get_texel_width(_texnoise);
var _texnoisetexelh = texture_get_texel_height(_texnoise);
var _texshadowmasktexelw = texture_get_texel_width(_texshadowmask);
var _texshadowmasktexelh = texture_get_texel_height(_texshadowmask);

/// Set texture interpolation
texture_set_interpolation(true);


/// Pass #0 : Apply downscaling
surface_set_target(surfacePPDownscaled);

// Clear
draw_clear_alpha(0, 0);

// Scale &amp; draw the application surface
// (application surface can be substituted with any surface that contains the image that you want to apply the filter obviously)
draw_surface_stretched(application_surface, 0, 0, surfaceDownscaledWid, surfaceDownscaledHei);

surface_reset_target();


/// Pass #1 : Screen filter (shadowmask, scanline etc..)
// Feed the results into the temp. surface #1
var _surfw = surface_get_width(surfacePPTemp1);
var _surfh = surface_get_height(surfacePPTemp1);
surface_set_target(surfacePPTemp1);

// Set the shader
shader_set(shd_retroscreen_screenfilter);

// Prepare the uniforms
var _u_time                 = shader_get_uniform(shd_retroscreen_screenfilter, "uTime");
var _u_shadowmaskintensity  = shader_get_uniform(shd_retroscreen_screenfilter, "uShadowmaskIntensity");
var _u_scanlineintensity    = shader_get_uniform(shd_retroscreen_screenfilter, "uScanlineIntensity");
var _u_bleendintensity      = shader_get_uniform(shd_retroscreen_screenfilter, "uBleedIntensity");
var _u_bleendsize           = shader_get_uniform(shd_retroscreen_screenfilter, "uBleedSize");
var _u_tintintensity        = shader_get_uniform(shd_retroscreen_screenfilter, "uTintIntensity");
var _u_vignetteintensity    = shader_get_uniform(shd_retroscreen_screenfilter, "uVignetteIntensity");
var _u_grainintensity       = shader_get_uniform(shd_retroscreen_screenfilter, "uFilmgrainIntensity");
var _u_brightness           = shader_get_uniform(shd_retroscreen_screenfilter, "uBrightness");
var _u_contrast             = shader_get_uniform(shd_retroscreen_screenfilter, "uContrast");
var _u_screentexelsize      = shader_get_uniform(shd_retroscreen_screenfilter, "uScreenTexelSize");
var _u_scaledscreentexelsize= shader_get_uniform(shd_retroscreen_screenfilter, "uScaledScreenTexelSize");
var _u_noisetexelsize       = shader_get_uniform(shd_retroscreen_screenfilter, "uNoiseTexelSize");
var _u_shadowmasktexelsize  = shader_get_uniform(shd_retroscreen_screenfilter, "uShadowmaskTexelSize");
var _samp_noise      = shader_get_sampler_index(shd_retroscreen_screenfilter, "uTexNoise");
var _samp_shadowmask = shader_get_sampler_index(shd_retroscreen_screenfilter, "uTexShadowmask");
shader_set_uniform_f(_u_time, _time); // time
shader_set_uniform_f(_u_shadowmaskintensity, crtShadowmask); // intensity of shadow mask effect
shader_set_uniform_f(_u_scanlineintensity, crtScanline); // intensity of scanline
shader_set_uniform_f(_u_bleendintensity, crtBleed); // intensity of colour bleed
shader_set_uniform_f(_u_bleendsize, crtBleedSize); // size of colour bleed
shader_set_uniform_f(_u_tintintensity, crtTint); // intensity of dynamic colour tint
shader_set_uniform_f(_u_vignetteintensity, crtVignette); // intensity of vignette
shader_set_uniform_f(_u_grainintensity, crtFilmgrain); // intensity of film grain
shader_set_uniform_f(_u_brightness, crtBrightness); // brightness boost adjustment
shader_set_uniform_f(_u_contrast, crtContrast); // contrast adjustment
shader_set_uniform_f(_u_screentexelsize, 1 / _surfw, 1 / _surfh); // texel size on surface that's being drawn to
shader_set_uniform_f(_u_scaledscreentexelsize, 1 / surfaceDownscaledWid, 1 / surfaceDownscaledHei); // texel size on downscaled surface
shader_set_uniform_f(_u_noisetexelsize, _texnoisetexelw, _texnoisetexelh); // texel size of noise texture
shader_set_uniform_f(_u_shadowmasktexelsize, _texshadowmasktexelw, _texshadowmasktexelh); // texel size of shadow mask texture
texture_set_stage(_samp_noise, _texnoise); // noise texture
texture_set_stage(_samp_shadowmask, _texshadowmask); // shadow mask texture

// Draw downscaled surface
draw_surface_stretched(surfacePPDownscaled, 0, 0, _surfw, _surfh);

// Reset shader
shader_reset();
surface_reset_target();


/// Pass #2 : CRT Screen distortion + Border reflection
// Feed the results into the temp. surface #2
var _surfw = surface_get_width(surfacePPTemp2);
var _surfh = surface_get_height(surfacePPTemp2);
surface_set_target(surfacePPTemp2);

// Set the shader
shader_set(shd_retroscreen_distortion);
// Prepare the uniforms
var _u_time                 = shader_get_uniform(shd_retroscreen_distortion, "uTime");
var _u_distortionintensity  = shader_get_uniform(shd_retroscreen_distortion, "uScreenDistortIntensity");
var _u_reflectionintensity  = shader_get_uniform(shd_retroscreen_distortion, "uBorderReflectionIntensity");
var _u_specularcol          = shader_get_uniform(shd_retroscreen_distortion, "uSpecularLight");
var _u_specularpos          = shader_get_uniform(shd_retroscreen_distortion, "uSpecularLightOffset");
var _u_screentexelsize      = shader_get_uniform(shd_retroscreen_distortion, "uScreenTexelSize");
var _u_noisetexelsize       = shader_get_uniform(shd_retroscreen_distortion, "uNoiseTexelSize");
var _samp_noise             = shader_get_sampler_index(shd_retroscreen_distortion, "uTexNoise");
shader_set_uniform_f(_u_time, _time); // time
shader_set_uniform_f(_u_distortionintensity, crtDistortion); // screen distortion intensity
shader_set_uniform_f(_u_reflectionintensity, crtReflection); // border reflection intensity
shader_set_uniform_f(_u_specularcol, crtSpecularR, crtSpecularG, crtSpecularB, crtSpecularAmp); // specular light colour properties (in vec4 format, rgb colour [in 0..1 range] with intensity)
shader_set_uniform_f(_u_specularpos, crtSpecularOffX, crtSpecularOffY); // specular light's offset from center
shader_set_uniform_f(_u_screentexelsize, 1 / _surfw, 1 / _surfh); // texel size on surface that's being drawn
shader_set_uniform_f(_u_noisetexelsize, _texnoisetexelw, _texnoisetexelh); // texel size of noise texture
texture_set_stage(_samp_noise, _texnoise); // noise texture

// Draw surface
draw_surface_stretched(surfacePPTemp1, 0, 0, _surfw, _surfh);

// Reset shader
shader_reset();
surface_reset_target();


/// Pass #3 : (final postprocessing effects) zoom blur with chromatic abberation
var _winw = window_get_width();
var _winh = window_get_height();

// Set the shader
shader_set(shd_retroscreen_postprocessing);
// Prepare the uniforms
var _u_time             = shader_get_uniform(shd_retroscreen_postprocessing, "uTime");
var _u_glowfactor       = shader_get_uniform(shd_retroscreen_postprocessing, "uGlowFactor");
var _u_glowtint         = shader_get_uniform(shd_retroscreen_postprocessing, "uGlowTintIntensity");
var _u_blursize         = shader_get_uniform(shd_retroscreen_postprocessing, "uBlurSize");
var _u_blurzoom         = shader_get_uniform(shd_retroscreen_postprocessing, "uBlurZoomIntensity");
var _u_screentexelsize  = shader_get_uniform(shd_retroscreen_postprocessing, "uScreenTexelSize");
var _u_noisetexelsize   = shader_get_uniform(shd_retroscreen_postprocessing, "uNoiseTexelSize");
var _samp_noise         = shader_get_sampler_index(shd_retroscreen_postprocessing, "uTexNoise");
var _samp_rainbowlut    = shader_get_sampler_index(shd_retroscreen_postprocessing, "uTexRainbow");
shader_set_uniform_f(_u_time, _time); // time
shader_set_uniform_f(_u_glowfactor, crtGlowFactor); // factor/multiplier of glow (hard-capped at certain amount)
shader_set_uniform_f(_u_glowtint, crtGlowTint); // colour tint amount of blur (like chromatic aberration)
shader_set_uniform_f(_u_blursize, crtBlurSize); // half size of blur
shader_set_uniform_f(_u_blurzoom, crtBlurZoom); // zoom amount of blur
shader_set_uniform_f(_u_screentexelsize, 1 / _winw, 1 / _winh); // texel size of screen
shader_set_uniform_f(_u_noisetexelsize, _texnoisetexelw, _texnoisetexelh); // texel size of noise texture
texture_set_stage(_samp_noise, _texnoise); // noise texture
texture_set_stage(_samp_rainbowlut, _texrainbowlut); // RGB tint lookup texture

// Draw surface
draw_surface_stretched(surfacePPTemp2, 0, 0, _winw, _winh);

// Reset shader
shader_reset();

/// Reset texture interpolation
texture_set_interpolation(false);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
